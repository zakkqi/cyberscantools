# backend/services/web_vulnerability_scanner.py
from zapv2 import ZAPv2
import time
import uuid
from threading import Thread
from pymongo import MongoClient
from datetime import datetime

# MongoDB Connection
client = MongoClient('mongodb://localhost:27017/')
db = client.cyberscan
scan_history_collection = db.scan_history

class WebVulnerabilityScanner:
    def __init__(self):
        """Initialize ZAP connection"""
        self.zap = ZAPv2(
            apikey='',
            proxies={
                'http': 'http://127.0.0.1:8080',
                'https': 'http://127.0.0.1:8080'
            }
        )
        self.scan_progress = {}
    
    def test_connection(self):
        """Test if ZAP is accessible"""
        try:
            version = self.zap.core.version
            return True, f"Connected to ZAP version: {version}"
        except Exception as e:
            return False, f"Connection failed: {str(e)}"
    
    def get_scan_progress(self, scan_id):
        """Get progress for a specific scan"""
        return self.scan_progress.get(scan_id, {
            'status': 'not_found',
            'progress': 0,
            'phase': 'idle'
        })
    
    def start_scan_with_user(self, target, scan_mode='basic', user_id=None):
        """Start a scan with user tracking"""
        scan_id = str(uuid.uuid4())
        
        # Initialize progress
        self.scan_progress[scan_id] = {
            'status': 'initializing',
            'progress': 0,
            'phase': 'starting',
            'target': target,
            'mode': scan_mode,
            'alerts': []
        }
        
        # Store in database if user is logged in
        if user_id:
            try:
                scan = {
                    "scan_id": scan_id,
                    "user_id": user_id,
                    "target": target,
                    "scan_type": "web",
                    "scan_mode": scan_mode,
                    "created_at": datetime.utcnow(),
                    "status": "running"
                }
                scan_history_collection.insert_one(scan)
            except Exception as e:
                print(f"Error saving scan to MongoDB: {e}")
        
        # Run scan in background
        thread = Thread(target=self._run_scan_by_mode, args=(target, scan_id, scan_mode, user_id))
        thread.daemon = True  # Allow app to exit even if thread is running
        thread.start()
        
        return {'scan_id': scan_id, 'status': 'started'}
    
    def _run_scan_by_mode(self, target, scan_id, mode, user_id=None):
        """Run different scan types based on mode"""
        try:
            if mode == 'passive':
                self._run_passive_scan(target, scan_id)
            elif mode == 'active' or mode == 'full':
                self._run_active_scan(target, scan_id)
            else:  # basic
                self._run_basic_scan(target, scan_id)
            
            # Update database if user is logged in
            if user_id and self.scan_progress[scan_id]['status'] == 'completed':
                try:
                    update_data = {
                        "status": "completed",
                        "completed_at": datetime.utcnow(),
                        "results": {
                            "alerts": self.scan_progress[scan_id]['alerts'],
                            "total_alerts": self.scan_progress[scan_id]['total_alerts']
                        }
                    }
                    
                    scan_history_collection.update_one(
                        {"scan_id": scan_id},
                        {"$set": update_data}
                    )
                except Exception as e:
                    print(f"Error updating scan in MongoDB: {e}")
        except Exception as e:
            # Update error status
            self.scan_progress[scan_id].update({
                'status': 'error',
                'error': str(e),
                'progress': self.scan_progress[scan_id].get('progress', 0)
            })
            
            # Update database
            if user_id:
                try:
                    scan_history_collection.update_one(
                        {"scan_id": scan_id},
                        {"$set": {"status": "error", "error": str(e)}}
                    )
                except Exception as db_error:
                    print(f"Error updating scan error in MongoDB: {db_error}")
    
    def _run_passive_scan(self, target, scan_id):
        """Run passive scan only - no spider, no active scan"""
        try:
            # Clear session
            self.zap.core.new_session()
            
            # Normalize URL
            if not target.startswith(('http://', 'https://')):
                target = f'http://{target}'
            
            self.scan_progress[scan_id].update({
                'status': 'running',
                'progress': 10,
                'phase': 'accessing_target'
            })
            
            # Just access the URL
            self.zap.urlopen(target)
            time.sleep(2)
            
            self.scan_progress[scan_id].update({
                'progress': 30,
                'phase': 'passive_scan_starting'
            })
            
            # Wait for passive scan to complete
            while int(self.zap.pscan.records_to_scan) > 0:
                records = int(self.zap.pscan.records_to_scan)
                progress = 30 + ((100 - records) / 100 * 60)  # 30-90% progress
                
                self.scan_progress[scan_id].update({
                    'progress': min(progress, 90),
                    'phase': 'passive_scan_running',
                    'passive_remaining': records
                })
                time.sleep(1)
            
            # Get results - only passive scan alerts
            alerts = self.zap.core.alerts(baseurl=target)
            formatted_alerts = self._format_alerts(alerts)
            
            self.scan_progress[scan_id].update({
                'status': 'completed',
                'progress': 100,
                'phase': 'completed',
                'total_alerts': len(alerts),
                'alerts': formatted_alerts
            })
            
        except Exception as e:
            self.scan_progress[scan_id].update({
                'status': 'error',
                'error': str(e),
                'progress': self.scan_progress[scan_id].get('progress', 0)
            })
    
    def _run_basic_scan(self, target, scan_id):
        """Run basic scan - spider + passive scan"""
        try:
            # Clear session
            self.zap.core.new_session()
            
            # Normalize URL
            if not target.startswith(('http://', 'https://')):
                target = f'http://{target}'
            
            self.scan_progress[scan_id].update({
                'status': 'running',
                'progress': 5,
                'phase': 'accessing_target'
            })
            
            # Access target
            self.zap.urlopen(target)
            time.sleep(2)
            
            self.scan_progress[scan_id].update({
                'progress': 10,
                'phase': 'spider_starting'
            })
            
            # Spider the target
            spider_scan_id = self.zap.spider.scan(target)
            
            # Monitor spider progress
            while int(self.zap.spider.status(spider_scan_id)) < 100:
                spider_progress = int(self.zap.spider.status(spider_scan_id))
                overall_progress = 10 + (spider_progress * 0.4)  # Spider is 40% of total
                
                self.scan_progress[scan_id].update({
                    'progress': overall_progress,
                    'phase': 'spider_running',
                    'spider_progress': spider_progress
                })
                time.sleep(1)
            
            self.scan_progress[scan_id].update({
                'progress': 50,
                'phase': 'spider_complete'
            })
            
            # Passive scan
            self.scan_progress[scan_id].update({
                'progress': 55,
                'phase': 'passive_scan_starting'
            })
            
            # Monitor passive scan
            initial_records = int(self.zap.pscan.records_to_scan)
            while int(self.zap.pscan.records_to_scan) > 0:
                remaining = int(self.zap.pscan.records_to_scan)
                if initial_records > 0:
                    passive_progress = ((initial_records - remaining) / initial_records) * 100
                    overall_progress = 55 + (passive_progress * 0.4)  # Passive is 40% of total
                else:
                    overall_progress = 95
                
                self.scan_progress[scan_id].update({
                    'progress': overall_progress,
                    'phase': 'passive_scan_running',
                    'passive_remaining': remaining
                })
                time.sleep(1)
            
            # Get results
            alerts = self.zap.core.alerts(baseurl=target)
            formatted_alerts = self._format_alerts(alerts)
            
            self.scan_progress[scan_id].update({
                'status': 'completed',
                'progress': 100,
                'phase': 'completed',
                'total_alerts': len(alerts),
                'alerts': formatted_alerts
            })
            
        except Exception as e:
            self.scan_progress[scan_id].update({
                'status': 'error',
                'error': str(e),
                'progress': self.scan_progress[scan_id].get('progress', 0)
            })
    
    def _run_active_scan(self, target, scan_id):
        """Run full active scan - spider + passive + active scan"""
        try:
            # Clear session
            self.zap.core.new_session()
            
            # Normalize URL
            if not target.startswith(('http://', 'https://')):
                target = f'http://{target}'
            
            self.scan_progress[scan_id].update({
                'status': 'running',
                'progress': 5,
                'phase': 'accessing_target'
            })
            
            # Access target
            self.zap.urlopen(target)
            time.sleep(2)
            
            # Spider first
            self.scan_progress[scan_id].update({
                'progress': 10,
                'phase': 'spider_starting'
            })
            
            spider_scan_id = self.zap.spider.scan(target)
            
            while int(self.zap.spider.status(spider_scan_id)) < 100:
                spider_progress = int(self.zap.spider.status(spider_scan_id))
                overall_progress = 10 + (spider_progress * 0.25)  # Spider is 25% of total
                
                self.scan_progress[scan_id].update({
                    'progress': overall_progress,
                    'phase': 'spider_running',
                    'spider_progress': spider_progress
                })
                time.sleep(1)
            
            # Wait for passive scan
            self.scan_progress[scan_id].update({
                'progress': 35,
                'phase': 'passive_scan_starting'
            })
            
            initial_records = int(self.zap.pscan.records_to_scan)
            while int(self.zap.pscan.records_to_scan) > 0:
                remaining = int(self.zap.pscan.records_to_scan)
                if initial_records > 0:
                    passive_progress = ((initial_records - remaining) / initial_records) * 100
                    overall_progress = 35 + (passive_progress * 0.25)  # Passive is 25% of total
                else:
                    overall_progress = 60
                
                self.scan_progress[scan_id].update({
                    'progress': overall_progress,
                    'phase': 'passive_scan_running',
                    'passive_remaining': remaining
                })
                time.sleep(1)
            
            # Active scan
            self.scan_progress[scan_id].update({
                'progress': 60,
                'phase': 'active_scan_starting'
            })
            
            # Fix: Use correct method names for ZAP API with robust error handling
            try:
                # Try to set scan policy (using different possible methods)
                try:
                    self.zap.ascan.set_option_attack_strength('MEDIUM')
                    self.zap.ascan.set_option_alert_threshold('LOW')
                except Exception as e1:
                    try:
                        self.zap.ascan.set_option('attackStrength', 'MEDIUM')
                        self.zap.ascan.set_option('alertThreshold', 'LOW')
                    except Exception as e2:
                        print(f"Could not set active scan options, using defaults: {e1}, {e2}")
                        
                # Start active scan
                ascan_id = self.zap.ascan.scan(target)
                
                # Monitor active scan progress
                while int(self.zap.ascan.status(ascan_id)) < 100:
                    active_progress = int(self.zap.ascan.status(ascan_id))
                    overall_progress = 60 + (active_progress * 0.35)  # Active is 35% of total
                    
                    self.scan_progress[scan_id].update({
                        'progress': overall_progress,
                        'phase': 'active_scan_running',
                        'active_progress': active_progress
                    })
                    time.sleep(2)
                
                # Get all alerts (passive + active)
                alerts = self.zap.core.alerts(baseurl=target)
                formatted_alerts = self._format_alerts(alerts)
                
                self.scan_progress[scan_id].update({
                    'status': 'completed',
                    'progress': 100,
                    'phase': 'completed',
                    'total_alerts': len(alerts),
                    'alerts': formatted_alerts
                })
            except Exception as scan_error:
                # If active scan fails, still try to get passive results
                self.scan_progress[scan_id].update({
                    'progress': 85,
                    'phase': 'active_scan_failed_getting_results'
                })
                
                alerts = self.zap.core.alerts(baseurl=target)
                formatted_alerts = self._format_alerts(alerts)
                
                self.scan_progress[scan_id].update({
                    'status': 'completed',
                    'progress': 100,
                    'phase': 'completed_with_errors',
                    'active_scan_error': str(scan_error),
                    'total_alerts': len(alerts),
                    'alerts': formatted_alerts
                })
            
        except Exception as e:
            self.scan_progress[scan_id].update({
                'status': 'error',
                'error': str(e),
                'progress': self.scan_progress[scan_id].get('progress', 0)
            })
    
    def _format_alerts(self, alerts):
        """Format alerts consistently"""
        formatted = []
        for alert in alerts:
            formatted.append({
                'name': alert.get('name'),
                'risk': alert.get('risk'),
                'confidence': alert.get('confidence'),
                'description': alert.get('description'),
                'url': alert.get('url'),
                'solution': alert.get('solution'),
                'reference': alert.get('reference'),
                'cwe_id': alert.get('cweid'),
                'wasc_id': alert.get('wascid'),
                'evidence': alert.get('evidence'),
                'param': alert.get('param'),
                'attack': alert.get('attack'),
                'method': alert.get('method'),
                'alert_ref': alert.get('alertRef'),
                'source_id': alert.get('sourceId')
            })
        return formatted
    
    def simple_scan(self, target, scan_options=None):
        """Legacy method for compatibility"""
        scan_id = str(uuid.uuid4())
        self._run_basic_scan(target, scan_id)
        
        # Wait for scan to complete
        max_wait_time = 300  # 5 minutes
        wait_time = 0
        sleep_interval = 5
        
        while wait_time < max_wait_time:
            progress = self.get_scan_progress(scan_id)
            if progress.get('status') == 'completed':
                return {
                    'target': target,
                    'total_alerts': progress.get('total_alerts', 0),
                    'alerts': progress.get('alerts', [])
                }
            elif progress.get('status') == 'error':
                return {'error': progress.get('error', 'Unknown error')}
            
            time.sleep(sleep_interval)
            wait_time += sleep_interval
        
        return {'error': 'Scan timeout'}
    
    def passive_scan(self, target):
        """Legacy method for compatibility"""
        scan_id = str(uuid.uuid4())
        self._run_passive_scan(target, scan_id)
        
        # Wait for scan to complete
        max_wait_time = 300  # 5 minutes
        wait_time = 0
        sleep_interval = 5
        
        while wait_time < max_wait_time:
            progress = self.get_scan_progress(scan_id)
            if progress.get('status') == 'completed':
                return {
                    'target': target,
                    'total_alerts': progress.get('total_alerts', 0),
                    'alerts': progress.get('alerts', [])
                }
            elif progress.get('status') == 'error':
                return {'error': progress.get('error', 'Unknown error')}
            
            time.sleep(sleep_interval)
            wait_time += sleep_interval
        
        return {'error': 'Scan timeout'}
    
    def active_scan(self, target):
        """Legacy method for compatibility"""
        scan_id = str(uuid.uuid4())
        self._run_active_scan(target, scan_id)
        
        # Wait for scan to complete
        max_wait_time = 600  # 10 minutes
        wait_time = 0
        sleep_interval = 5
        
        while wait_time < max_wait_time:
            progress = self.get_scan_progress(scan_id)
            if progress.get('status') == 'completed':
                return {
                    'target': target,
                    'total_alerts': progress.get('total_alerts', 0),
                    'alerts': progress.get('alerts', [])
                }
            elif progress.get('status') == 'error':
                return {'error': progress.get('error', 'Unknown error')}
            
            time.sleep(sleep_interval)
            wait_time += sleep_interval
        
        return {'error': 'Scan timeout'}
    
    def cleanup_old_scans(self):
        """Clean up old scan progress data"""
        current_time = time.time()
        expired_scans = []
        
        for scan_id, progress in self.scan_progress.items():
            # Keep completed scans for 1 hour, others for 12 hours
            expiry_time = 3600 if progress.get('status') == 'completed' else 43200
            
            if progress.get('last_updated', 0) + expiry_time < current_time:
                expired_scans.append(scan_id)
                
        for scan_id in expired_scans:
            self.scan_progress.pop(scan_id, None)