# backend/services/web_vulnerability_scanner.py
from zapv2 import ZAPv2
import time
import uuid
from threading import Thread
from pymongo import MongoClient
from datetime import datetime
import re

# MongoDB Connection
client = MongoClient('mongodb://localhost:27017/')
db = client.cyberscan
scan_history_collection = db.scan_history

class WebVulnerabilityScanner:
    def __init__(self):
        """Initialize ZAP connection"""
        self.zap = ZAPv2(
            apikey='3bcguo87sqmalkklrpieq4h3l9',
            proxies={
                'http': 'http://127.0.0.1:8080',
                'https': 'http://127.0.0.1:8080',
                'http': 'http://127.0.0.1:8081',
                'https': 'http://127.0.0.1:8081'
            }
        )
        self.scan_progress = {}
    
    def test_connection(self):
        """Test if ZAP is accessible"""
        try:
            version = self.zap.core.version
            return True, f"Connected to ZAP version: {version}"
        except Exception as e:
            return False, f"Connection failed: {str(e)}"
    
    def get_scan_progress(self, scan_id):
        """Get progress for a specific scan"""
        return self.scan_progress.get(scan_id, {
            'status': 'not_found',
            'progress': 0,
            'phase': 'idle'
        })
    
    def start_scan_with_user(self, target, scan_mode='basic', user_id=None):
        """Start a scan with user tracking"""
        scan_id = str(uuid.uuid4())
        
        # Initialize progress
        self.scan_progress[scan_id] = {
            'status': 'initializing',
            'progress': 0,
            'phase': 'starting',
            'target': target,
            'mode': scan_mode,
            'alerts': []
        }
        
        # Store in database if user is logged in
        if user_id:
            try:
                scan = {
                    "scan_id": scan_id,
                    "user_id": user_id,
                    "target": target,
                    "scan_type": "web",
                    "scan_mode": scan_mode,
                    "created_at": datetime.utcnow(),
                    "status": "running"
                }
                scan_history_collection.insert_one(scan)
            except Exception as e:
                print(f"Error saving scan to MongoDB: {e}")
        
        # Run scan in background
        thread = Thread(target=self._run_scan_by_mode, args=(target, scan_id, scan_mode, user_id))
        thread.daemon = True  # Allow app to exit even if thread is running
        thread.start()
        
        return {'scan_id': scan_id, 'status': 'started'}
    
    def _run_scan_by_mode(self, target, scan_id, mode, user_id=None):
        """Run different scan types based on mode"""
        try:
            if mode == 'passive':
                self._run_passive_scan(target, scan_id)
            elif mode == 'active' or mode == 'full':
                self._run_active_scan(target, scan_id)
            else:  # basic
                self._run_basic_scan(target, scan_id)
            
            # Update database if user is logged in
            if user_id and self.scan_progress[scan_id]['status'] == 'completed':
                try:
                    update_data = {
                        "status": "completed",
                        "completed_at": datetime.utcnow(),
                        "results": {
                            "alerts": self.scan_progress[scan_id]['alerts'],
                            "total_alerts": self.scan_progress[scan_id]['total_alerts'],
                            "technologies": self.scan_progress[scan_id].get('technologies', [])
                        }
                    }
                    
                    scan_history_collection.update_one(
                        {"scan_id": scan_id},
                        {"$set": update_data}
                    )
                except Exception as e:
                    print(f"Error updating scan in MongoDB: {e}")
        except Exception as e:
            # Update error status
            self.scan_progress[scan_id].update({
                'status': 'error',
                'error': str(e),
                'progress': self.scan_progress[scan_id].get('progress', 0)
            })
            
            # Update database
            if user_id:
                try:
                    scan_history_collection.update_one(
                        {"scan_id": scan_id},
                        {"$set": {"status": "error", "error": str(e)}}
                    )
                except Exception as db_error:
                    print(f"Error updating scan error in MongoDB: {db_error}")
    
    def _get_technologies(self, target):
        """Get detected technologies from ZAP"""
        try:
            technologies = []
            
            # Get all sites from ZAP
            sites = self.zap.core.sites
            
            for site in sites:
                if target in site:
                    try:
                        # Extract technology info from responses
                        site_technologies = self._extract_tech_from_responses(target)
                        technologies.extend(site_technologies)
                    except Exception as e:
                        print(f"Error extracting tech from site {site}: {e}")
            
            # Remove duplicates and return
            unique_technologies = []
            seen_names = set()
            
            for tech in technologies:
                if tech['name'] not in seen_names:
                    unique_technologies.append(tech)
                    seen_names.add(tech['name'])
            
            return unique_technologies[:10]  # Limit to top 10
            
        except Exception as e:
            print(f"Error getting technologies: {e}")
            return []

    def _extract_tech_from_responses(self, target_url):
        """Extract technology information from HTTP responses"""
        technologies = []
        
        try:
            # Get messages for the target
            messages = self.zap.core.messages()
            
            for message in messages:
                message_url = message.get('url', '')
                if target_url in message_url:
                    # Check response headers for technology indicators
                    response_header = message.get('responseHeader', '')
                    response_body = message.get('responseBody', '')
                    
                    # Server header analysis
                    if 'Server:' in response_header:
                        server_lines = [line for line in response_header.split('\n') if line.strip().startswith('Server:')]
                        for server_line in server_lines:
                            server = server_line.replace('Server:', '').strip()
                            if server and not any(t['name'] == server for t in technologies):
                                technologies.append({
                                    'name': server,
                                    'version': self._extract_version(server),
                                    'categories': ['Web servers'],
                                    'confidence': 90
                                })
                    
                    # X-Powered-By header
                    if 'X-Powered-By:' in response_header:
                        powered_lines = [line for line in response_header.split('\n') if line.strip().startswith('X-Powered-By:')]
                        for powered_line in powered_lines:
                            powered = powered_line.replace('X-Powered-By:', '').strip()
                            if powered and not any(t['name'] == powered for t in technologies):
                                technologies.append({
                                    'name': powered,
                                    'version': self._extract_version(powered),
                                    'categories': ['Programming languages', 'Web frameworks'],
                                    'confidence': 85
                                })
                    
                    # Content analysis for common technologies
                    content_technologies = self._detect_from_content(response_body)
                    for tech in content_technologies:
                        if not any(t['name'] == tech['name'] for t in technologies):
                            technologies.append(tech)
            
            return technologies
            
        except Exception as e:
            print(f"Error extracting technologies: {e}")
            return []

    def _extract_version(self, tech_string):
        """Extract version number from technology string"""
        try:
            # Look for version patterns like "1.0", "2.1.3", etc.
            version_pattern = r'(\d+\.(?:\d+\.)*\d+)'
            match = re.search(version_pattern, tech_string)
            
            if match:
                return match.group(1)
            
            return None
        except:
            return None

    def _detect_from_content(self, content):
        """Detect technologies from response content"""
        technologies = []
        
        try:
            if not content:
                return []
                
            content_lower = content.lower()
            
            # Common technology indicators
            tech_patterns = {
                'jquery': {
                    'patterns': ['jquery', 'jquery.min.js'],
                    'name': 'jQuery',
                    'categories': ['JavaScript libraries']
                },
                'bootstrap': {
                    'patterns': ['bootstrap', 'bootstrap.min.css', 'bootstrap.css'],
                    'name': 'Bootstrap',
                    'categories': ['UI frameworks']
                },
                'react': {
                    'patterns': ['react', 'reactdom', '_react'],
                    'name': 'React',
                    'categories': ['JavaScript libraries', 'UI frameworks']
                },
                'angular': {
                    'patterns': ['angular', 'ng-app', 'ng-controller'],
                    'name': 'Angular',
                    'categories': ['JavaScript libraries', 'UI frameworks']
                },
                'wordpress': {
                    'patterns': ['wp-content', 'wp-includes', '/wordpress/'],
                    'name': 'WordPress',
                    'categories': ['CMS', 'Blogs']
                },
                'vue': {
                    'patterns': ['vue.js', 'vue.min.js', 'v-if', 'v-for'],
                    'name': 'Vue.js',
                    'categories': ['JavaScript libraries', 'UI frameworks']
                },
                'font_awesome': {
                    'patterns': ['font-awesome', 'fontawesome', 'fa-'],
                    'name': 'Font Awesome',
                    'categories': ['Font scripts']
                },
                'google_analytics': {
                    'patterns': ['google-analytics', 'gtag', 'ga('],
                    'name': 'Google Analytics',
                    'categories': ['Analytics']
                },
                'apache': {
                    'patterns': ['apache/', 'apache http server'],
                    'name': 'Apache HTTP Server',
                    'categories': ['Web servers']
                },
                'nginx': {
                    'patterns': ['nginx/', 'nginx http server'],
                    'name': 'Nginx',
                    'categories': ['Web servers']
                }
            }
            
            for tech_key, tech_info in tech_patterns.items():
                for pattern in tech_info['patterns']:
                    if pattern in content_lower:
                        tech_found = {
                            'name': tech_info['name'],
                            'version': None,
                            'categories': tech_info['categories'],
                            'confidence': 70
                        }
                        
                        # Try to extract version for specific technologies
                        if tech_key == 'jquery':
                            jquery_version = re.search(r'jquery[/-](\d+\.\d+\.\d+)', content_lower)
                            if jquery_version:
                                tech_found['version'] = jquery_version.group(1)
                                tech_found['confidence'] = 85
                        
                        technologies.append(tech_found)
                        break
            
            return technologies
            
        except Exception as e:
            print(f"Error detecting from content: {e}")
            return []
    
    def _run_passive_scan(self, target, scan_id):
        """Run passive scan only - no spider, no active scan"""
        try:
            # Clear session
            self.zap.core.new_session()
            
            # Normalize URL
            if not target.startswith(('http://', 'https://')):
                target = f'http://{target}'
            
            self.scan_progress[scan_id].update({
                'status': 'running',
                'progress': 10,
                'phase': 'accessing_target'
            })
            
            # Just access the URL
            self.zap.urlopen(target)
            time.sleep(2)
            
            self.scan_progress[scan_id].update({
                'progress': 30,
                'phase': 'passive_scan_starting'
            })
            
            # Wait for passive scan to complete
            while int(self.zap.pscan.records_to_scan) > 0:
                records = int(self.zap.pscan.records_to_scan)
                progress = 30 + ((100 - records) / 100 * 60)  # 30-90% progress
                
                self.scan_progress[scan_id].update({
                    'progress': min(progress, 90),
                    'phase': 'passive_scan_running',
                    'passive_remaining': records
                })
                time.sleep(1)
            
            # Get results - only passive scan alerts
            alerts = self.zap.core.alerts(baseurl=target)
            formatted_alerts = self._format_alerts(alerts)
            
            # Get technologies
            technologies = self._get_technologies(target)
            
            self.scan_progress[scan_id].update({
                'status': 'completed',
                'progress': 100,
                'phase': 'completed',
                'total_alerts': len(alerts),
                'alerts': formatted_alerts,
                'technologies': technologies
            })
            
        except Exception as e:
            self.scan_progress[scan_id].update({
                'status': 'error',
                'error': str(e),
                'progress': self.scan_progress[scan_id].get('progress', 0)
            })
    
    def _run_basic_scan(self, target, scan_id):
        """Run basic scan - spider + passive scan"""
        try:
            # Clear session
            self.zap.core.new_session()
            
            # Normalize URL
            if not target.startswith(('http://', 'https://')):
                target = f'http://{target}'
            
            self.scan_progress[scan_id].update({
                'status': 'running',
                'progress': 5,
                'phase': 'accessing_target'
            })
            
            # Access target
            self.zap.urlopen(target)
            time.sleep(2)
            
            self.scan_progress[scan_id].update({
                'progress': 10,
                'phase': 'spider_starting'
            })
            
            # Spider the target
            spider_scan_id = self.zap.spider.scan(target)
            
            # Monitor spider progress
            while int(self.zap.spider.status(spider_scan_id)) < 100:
                spider_progress = int(self.zap.spider.status(spider_scan_id))
                overall_progress = 10 + (spider_progress * 0.4)  # Spider is 40% of total
                
                self.scan_progress[scan_id].update({
                    'progress': overall_progress,
                    'phase': 'spider_running',
                    'spider_progress': spider_progress
                })
                time.sleep(1)
            
            self.scan_progress[scan_id].update({
                'progress': 50,
                'phase': 'spider_complete'
            })
            
            # Passive scan
            self.scan_progress[scan_id].update({
                'progress': 55,
                'phase': 'passive_scan_starting'
            })
            
            # Monitor passive scan
            initial_records = int(self.zap.pscan.records_to_scan)
            while int(self.zap.pscan.records_to_scan) > 0:
                remaining = int(self.zap.pscan.records_to_scan)
                if initial_records > 0:
                    passive_progress = ((initial_records - remaining) / initial_records) * 100
                    overall_progress = 55 + (passive_progress * 0.4)  # Passive is 40% of total
                else:
                    overall_progress = 95
                
                self.scan_progress[scan_id].update({
                    'progress': overall_progress,
                    'phase': 'passive_scan_running',
                    'passive_remaining': remaining
                })
                time.sleep(1)
            
            # Get results
            alerts = self.zap.core.alerts(baseurl=target)
            formatted_alerts = self._format_alerts(alerts)
            
            # Get technologies
            technologies = self._get_technologies(target)
            
            self.scan_progress[scan_id].update({
                'status': 'completed',
                'progress': 100,
                'phase': 'completed',
                'total_alerts': len(alerts),
                'alerts': formatted_alerts,
                'technologies': technologies
            })
            
        except Exception as e:
            self.scan_progress[scan_id].update({
                'status': 'error',
                'error': str(e),
                'progress': self.scan_progress[scan_id].get('progress', 0)
            })
    
    def _run_active_scan(self, target, scan_id):
        """Run full active scan - spider + passive + active scan"""
        try:
            # Clear session
            self.zap.core.new_session()
            
            # Normalize URL
            if not target.startswith(('http://', 'https://')):
                target = f'http://{target}'
            
            self.scan_progress[scan_id].update({
                'status': 'running',
                'progress': 5,
                'phase': 'accessing_target'
            })
            
            # Access target
            self.zap.urlopen(target)
            time.sleep(2)
            
            # Spider first
            self.scan_progress[scan_id].update({
                'progress': 10,
                'phase': 'spider_starting'
            })
            
            spider_scan_id = self.zap.spider.scan(target)
            
            while int(self.zap.spider.status(spider_scan_id)) < 100:
                spider_progress = int(self.zap.spider.status(spider_scan_id))
                overall_progress = 10 + (spider_progress * 0.25)  # Spider is 25% of total
                
                self.scan_progress[scan_id].update({
                    'progress': overall_progress,
                    'phase': 'spider_running',
                    'spider_progress': spider_progress
                })
                time.sleep(1)
            
            # Wait for passive scan
            self.scan_progress[scan_id].update({
                'progress': 35,
                'phase': 'passive_scan_starting'
            })
            
            initial_records = int(self.zap.pscan.records_to_scan)
            while int(self.zap.pscan.records_to_scan) > 0:
                remaining = int(self.zap.pscan.records_to_scan)
                if initial_records > 0:
                    passive_progress = ((initial_records - remaining) / initial_records) * 100
                    overall_progress = 35 + (passive_progress * 0.25)  # Passive is 25% of total
                else:
                    overall_progress = 60
                
                self.scan_progress[scan_id].update({
                    'progress': overall_progress,
                    'phase': 'passive_scan_running',
                    'passive_remaining': remaining
                })
                time.sleep(1)
            
            # Active scan
            self.scan_progress[scan_id].update({
                'progress': 60,
                'phase': 'active_scan_starting'
            })
            
            # Fix: Use correct method names for ZAP API with robust error handling
            try:
                # Try to set scan policy (using different possible methods)
                try:
                    self.zap.ascan.set_option_attack_strength('MEDIUM')
                    self.zap.ascan.set_option_alert_threshold('LOW')
                except Exception as e1:
                    try:
                        self.zap.ascan.set_option('attackStrength', 'MEDIUM')
                        self.zap.ascan.set_option('alertThreshold', 'LOW')
                    except Exception as e2:
                        print(f"Could not set active scan options, using defaults: {e1}, {e2}")
                        
                # Start active scan
                ascan_id = self.zap.ascan.scan(target)
                
                # Monitor active scan progress
                while int(self.zap.ascan.status(ascan_id)) < 100:
                    active_progress = int(self.zap.ascan.status(ascan_id))
                    overall_progress = 60 + (active_progress * 0.35)  # Active is 35% of total
                    
                    self.scan_progress[scan_id].update({
                        'progress': overall_progress,
                        'phase': 'active_scan_running',
                        'active_progress': active_progress
                    })
                    time.sleep(2)
                
                # Get all alerts (passive + active)
                alerts = self.zap.core.alerts(baseurl=target)
                formatted_alerts = self._format_alerts(alerts)
                
                # Get technologies
                technologies = self._get_technologies(target)
                
                self.scan_progress[scan_id].update({
                    'status': 'completed',
                    'progress': 100,
                    'phase': 'completed',
                    'total_alerts': len(alerts),
                    'alerts': formatted_alerts,
                    'technologies': technologies
                })
            except Exception as scan_error:
                # If active scan fails, still try to get passive results
                self.scan_progress[scan_id].update({
                    'progress': 85,
                    'phase': 'active_scan_failed_getting_results'
                })
                
                alerts = self.zap.core.alerts(baseurl=target)
                formatted_alerts = self._format_alerts(alerts)
                
                # Get technologies
                technologies = self._get_technologies(target)
                
                self.scan_progress[scan_id].update({
                    'status': 'completed',
                    'progress': 100,
                    'phase': 'completed_with_errors',
                    'active_scan_error': str(scan_error),
                    'total_alerts': len(alerts),
                    'alerts': formatted_alerts,
                    'technologies': technologies
                })
            
        except Exception as e:
            self.scan_progress[scan_id].update({
                'status': 'error',
                'error': str(e),
                'progress': self.scan_progress[scan_id].get('progress', 0)
            })
    
    def _format_alerts(self, alerts):
        """Format alerts consistently"""
        formatted = []
        for alert in alerts:
            formatted.append({
                'name': alert.get('name'),
                'risk': alert.get('risk'),
                'confidence': alert.get('confidence'),
                'description': alert.get('description'),
                'url': alert.get('url'),
                'solution': alert.get('solution'),
                'reference': alert.get('reference'),
                'cwe_id': alert.get('cweid'),
                'wasc_id': alert.get('wascid'),
                'evidence': alert.get('evidence'),
                'param': alert.get('param'),
                'attack': alert.get('attack'),
                'method': alert.get('method'),
                'alert_ref': alert.get('alertRef'),
                'source_id': alert.get('sourceId')
            })
        return formatted
    
    def simple_scan(self, target, scan_options=None):
        """Legacy method for compatibility"""
        scan_id = str(uuid.uuid4())
        self._run_basic_scan(target, scan_id)
        
        # Wait for scan to complete
        max_wait_time = 300  # 5 minutes
        wait_time = 0
        sleep_interval = 5
        
        while wait_time < max_wait_time:
            progress = self.get_scan_progress(scan_id)
            if progress.get('status') == 'completed':
                return {
                    'target': target,
                    'total_alerts': progress.get('total_alerts', 0),
                    'alerts': progress.get('alerts', []),
                    'technologies': progress.get('technologies', [])
                }
            elif progress.get('status') == 'error':
                return {'error': progress.get('error', 'Unknown error')}
            
            time.sleep(sleep_interval)
            wait_time += sleep_interval
        
        return {'error': 'Scan timeout'}
    
    def passive_scan(self, target):
        """Legacy method for compatibility"""
        scan_id = str(uuid.uuid4())
        self._run_passive_scan(target, scan_id)
        
        # Wait for scan to complete
        max_wait_time = 300  # 5 minutes
        wait_time = 0
        sleep_interval = 5
        
        while wait_time < max_wait_time:
            progress = self.get_scan_progress(scan_id)
            if progress.get('status') == 'completed':
                return {
                    'target': target,
                    'total_alerts': progress.get('total_alerts', 0),
                    'alerts': progress.get('alerts', []),
                    'technologies': progress.get('technologies', [])
                }
            elif progress.get('status') == 'error':
                return {'error': progress.get('error', 'Unknown error')}
            
            time.sleep(sleep_interval)
            wait_time += sleep_interval
        
        return {'error': 'Scan timeout'}
    
    def active_scan(self, target):
        """Legacy method for compatibility"""
        scan_id = str(uuid.uuid4())
        self._run_active_scan(target, scan_id)
        
        # Wait for scan to complete
        max_wait_time = 600  # 10 minutes
        wait_time = 0
        sleep_interval = 5
        
        while wait_time < max_wait_time:
            progress = self.get_scan_progress(scan_id)
            if progress.get('status') == 'completed':
                return {
                    'target': target,
                    'total_alerts': progress.get('total_alerts', 0),
                    'alerts': progress.get('alerts', []),
                    'technologies': progress.get('technologies', [])
                }
            elif progress.get('status') == 'error':
                return {'error': progress.get('error', 'Unknown error')}
            
            time.sleep(sleep_interval)
            wait_time += sleep_interval
        
        return {'error': 'Scan timeout'}
    
    def cleanup_old_scans(self):
        """Clean up old scan progress data"""
        current_time = time.time()
        expired_scans = []
        
        for scan_id, progress in self.scan_progress.items():
            # Keep completed scans for 1 hour, others for 12 hours
            expiry_time = 3600 if progress.get('status') == 'completed' else 43200
            
            if progress.get('last_updated', 0) + expiry_time < current_time:
                expired_scans.append(scan_id)
                
        for scan_id in expired_scans:
            self.scan_progress.pop(scan_id, None)